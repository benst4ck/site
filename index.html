<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>webpack vue</title>
    <link href="https://fonts.googleapis.com/css?family=Arvo|Viga" rel="stylesheet">
    <link rel="stylesheet" href="symbol/style.css">
    <link rel="stylesheet" href="home.css">
    <link rel="stylesheet" href="src/articles/articles.css"> 
    <link rel="stylesheet" href="codeHighlight/code.highlight.css">
    <script src="codeHighlight/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <style>
		body {
		 	font-family: 'Viga', sans-serif;
		 	padding: 0px;
		 	margin: 0px;
		 	height: 4000px;
		 	background: #181a1b;
		}
  	</style>

</head>
<body>

	<div id="lightning"></div>
  <div id="ninja"></div>
  <div id="menu-toggle"></div>
  <div id="nav" class="menu-hidden"></div>
  <!--
  <div id="list"></div>
  <div id="article"></div>
  -->
  <article id="article">
    <h1 class="icon-quotes-left icon-quotes-right">stream 流</h1>
    <p class="note-p">流(stream)在 Node.js 中是处理流数据的抽象接口(abstract interface)。 stream 模块提供了基础的 API 。使用这些 API 可以很容易地来构建实现流接口的对象。
Node.js 提供了多种流对象。 例如， HTTP 请求 和 process.stdout 就都是流的实例。</p>
    <p class="note-p">流可以是可读的、可写的，或是可读写的。所有的流都是 EventEmitter 的实例。尽管所有的 Node.js 用户都应该理解流的工作方式，这点很重要， 但是 stream 模块本身只对于那些需要创建新的流的实例的开发者最有用处。 对于主要是 消费 流的开发者来说，他们很少(如果有的话)需要直接使用 stream 模块。</p>
    <h2 class="subtitle icon-arrow-right2">stream.Writable 类</h2>
    <p class="analysis icon-flickr">promise适合编写异步处理较多的应用</p>
    <p class="analysis icon-flickr">创建promise对象</p>
    <p class="note-s">安装方式 :</p>
    <span class="command">~$ npm i -D babel</span>
        <pre><code class="html">&lt;p&gt;hello&lt;/p&gt;
&lt;button class="menu-toggle" _v-a06a264a="" id="menu-toggle" style="top: 40px; position: fixed;"&gt;Toggle Menu&lt;/button&gt;</code></pre>

        <pre><code class="javascript">  
function $initHighlight(block, cls) {
  try {
    if (cls.search(/\bno\-highlight\b/) != -1)
      return process(block, true, 0x0F) +
             ` class="${cls}"`;
  } catch (e) {
    /* handle exception */
  }
  for (var i = 0 / 2; i < classes.length; i++) {
    if (checkCondition(classes[i]) === undefined)
      console.log('undefined');
  }
}</code></pre>
<pre><code class="javascript">  
  export  $initHighlight;

  Handlebars.registerHelper('unless_eq', function (a, b, opts) {
    return a === b
      ? opts.inverse(this)
      : opts.fn(this)
  })</code></pre>
<pre><code class="javascript">  
  function renderTemplateFiles (skipInterpolation) {
    skipInterpolation = typeof skipInterpolation === 'string'
      ? [skipInterpolation]
      : skipInterpolation
    return (files, metalsmith, done) => {
      const keys = Object.keys(files)
      const metalsmithMetadata = metalsmith.metadata()
      async.each(keys, (file, next) => {
        // skipping files with skipInterpolation option
        if (skipInterpolation && multimatch([file], skipInterpolation, { dot: true }).length) {
          return next()
        }
        const str = files[file].contents.toString()
        // do not attempt to render files that do not have mustaches
        if (!/{{([^{}]+)}}/g.test(str)) {
          return next()
        }
        render(str, metalsmithMetadata, (err, res) => {
          if (err) {
            err.message = `[${file}] ${err.message}`
            return next(err)
          }
          files[file].contents = new Buffer(res)
          next()
        })
      }, done)
    }
  }</code></pre>
        <p class="analysis icon-flickr">promise适合编写异步处理较多的应用</p>
        <p class="analysis icon-flickr">创建promise对象</p>
        <pre><code class="javascript">  var promise = new Promise(function(resolve, reject) {
    /* 异步处理 */
    /* 处理结束后 调用resolve或reject */
  });</code></pre>

  </article>
  <div id="backToTop"></div>
  <script src="dist/main.js"></script>

</body>
</html>